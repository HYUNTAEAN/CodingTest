# 문제조건

입력

팀수 , 가로, 세로

팀원수

가로x세로 배열
정수 = 사용 가능 자리, # = 사용불가


조건

팀이 분할시 만족도 down
옆에 다른 팀이 존재시 만족도 down

최적 자리 배치 찾기


# 생각



1. 만약 이진 트리로 만들면?

      3
      1 #
      9 3 1
      # 3 3 #
      # # 2 # #
      # # 2 # # #

-> 노드 가중치를 계산하면서 내려가면 위쪽에 치우치게됨 


2. 만약 이중 스택으로 만들면?

team = []
stack = [ 3, 0, 1, 1, 3, 3, 9, 3, 2, 0, 0, 2 ]

A팀이 4인이니까

stack.pop(0)을 team 스택에 넣으면서
sum(team)이 팀원수보다 같거나 높은지 체크

같거나 높으면 경우의 수로 저장하고 team.pop(0)

예) [3,0,1] -> [0,1,1,3] -> [1,1,3] -> [1,3] -> [3,3] -> [3,9] -> [9] -> [9,3] -> [3,2] -> [2,0] -> [2,0,0] -> [2,0,0,2]

반례 : 0은 건너뛰게 해야할듯, 단일 수로 수용 가능시 경우의 수로 저장하고 건너뛰는게 맞는듯, 배열 인덱스로 저장시켜야함

A팀 경우의 수

[(0,0),(0,2)] , [(0,2),(1,0)] , [(1,0),(1,1)] , [(1,1),(1,2)] , [(2,0)] , [(2,2),(2,3)] , [(2,3),(3,2)]

반례 : 1차원 배열 기준으로 근접 케이스만 등록 -> 만약 만족도가 극악인 배치일 경우에 대응 불가


3. 순열 조합으로 만들면?

from collections import combinations

앞 뒤는 상관없으니 permutations 보단 combinations가 어울릴듯?

for i in range(1,3) 까지 돌려서 순열 생성

단일 순열에선 팀원수 < 좌석수인 인덱스를 저장

이중 순열에선 sum(순열) > 좌석수인 인덱스를 저장


모든 케이스가 만들어지면 그에 대응하는 B팀의 순열도 생성
탐욕법으로 인접 인덱스 조건 전부 삭제
C도 반복

len합계가 제일 적은게 답
동률도 답


4. 이중 포문은?

단일 포지션부터 경우의 수에 저장후 이중 순열 계산

    for y in range(y):
      for x in range(x-1):

        if x+(x+1) < cost:
          lis.append(idx)

순열의 노가다에 불과함

하지만 순열로 해도 만족도부터 계산한 후, 순열의 경우를 줄여서 다음 팀의 순열을 구하는게 좋을듯함


